{
  "chainId": 1984,
  "receiverAddress": "0xc82fc3693d8a0d4aec570181db36201696b79f3a",
  "stackScript": "\"use strict\";\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _StackedFloat_Transfer, _StackedFloat_Approval;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst muffin_utils_1 = require(\"muffin-utils\");\nclass StackedFloat extends muffin_utils_1.App {\n    constructor(data) {\n        super(data);\n        this.tokenName = 'Stacked Float';\n        this.tokenSymbol = 'SFT';\n        // Events\n        _StackedFloat_Transfer.set(this, (from, to, value) => {\n            if (value > this.balances[from]) {\n                throw 'Not enough funds.';\n            }\n            this.balances[from] -= value;\n            if (!this.balances[to]) {\n                this.balances[to] = 0;\n            }\n            this.balances[to] += value;\n            this.blocks[from] = 0;\n            this.stakes[from] = 0;\n        });\n        _StackedFloat_Approval.set(this, (owner, spender, value) => {\n            if (!this.allowed[this.msg.sender]) {\n                this.allowed[this.msg.sender] = {};\n            }\n            this.allowed[this.msg.sender][spender] = value;\n        }\n        // Methods\n        );\n        // Methods\n        this.name = () => {\n            return this.tokenName;\n        };\n        this.symbol = () => {\n            return this.tokenSymbol;\n        };\n        this.totalSupply = () => {\n            return this.tokenTotalSupply;\n        };\n        this.balanceOf = (owner) => {\n            if (!this.balances[owner]) {\n                return 0;\n            }\n            return this.balances[owner];\n        };\n        this.transfer = (to, value) => {\n            __classPrivateFieldGet(this, _StackedFloat_Transfer, \"f\").call(this, this.msg.sender, to, value);\n        };\n        this.transferFrom = (from, to, value) => {\n            if (!this.allowed[from] || !this.allowed[from][this.msg.sender]) {\n                throw 'Not allowed.';\n            }\n            if (value > this.allowed[from][this.msg.sender]) {\n                throw 'Amount unallowed.';\n            }\n            this.allowed[from][this.msg.sender] -= value;\n            __classPrivateFieldGet(this, _StackedFloat_Transfer, \"f\").call(this, from, to, value);\n        };\n        this.approve = (spender, value) => {\n            if (!this.balances[this.msg.sender] ||\n                value > this.balances[this.msg.sender]) {\n                throw 'Not enough funds.';\n            }\n            __classPrivateFieldGet(this, _StackedFloat_Approval, \"f\").call(this, this.msg.sender, spender, value);\n        };\n        this.allowance = (owner, spender) => {\n            if (!this.allowed[owner] || !this.allowed[owner][spender]) {\n                return 0;\n            }\n            return this.allowed[owner][spender];\n        };\n        // Minting\n        this.mint = (account, amount) => {\n            if (this.msg.amount < amount * 1000) {\n                throw 'Not enough funds. A StackedFloat costs 1000 FLT.';\n            }\n            if (this.msg.amount > amount * 1000) {\n                throw 'Too much funds. Be careful when making transactions!';\n            }\n            if (!this.balances[account]) {\n                this.balances[account] = 0;\n            }\n            this.tokenTotalSupply += amount;\n            this.balances[account] += amount;\n        };\n        // Burning\n        this.burn = (account, amount) => {\n            if (this.balances[account] < amount) {\n                throw 'Balance insufficient.';\n            }\n            this.tokenTotalSupply -= amount;\n            this.balances[account] -= amount;\n            this.msg.makeTransaction(account, amount * 1000);\n        };\n        if (!this.tokenTotalSupply) {\n            this.tokenTotalSupply = 0;\n        }\n        if (!this.balances) {\n            this.balances = {};\n        }\n        if (!this.allowed) {\n            this.allowed = {};\n        }\n        if (!this.blocks) {\n            this.blocks = {};\n        }\n        if (!this.stakes) {\n            this.stakes = {};\n        }\n    }\n}\n_StackedFloat_Transfer = new WeakMap(), _StackedFloat_Approval = new WeakMap();\n"
}
