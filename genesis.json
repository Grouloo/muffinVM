{
  "chainId": 1984,
  "blockHash": "0x0",
  "blockHeight": 0,
  "taxRate": 0.01,

  "accounts": [
    {
      "address": "0x0",
      "balance": 1000,
      "isOwned": false,
      "contract": {
        "environment": "nodejs",
        "className": "StackedFloat",
        "storage": {
          "balances": { "0xc82fc3693d8a0d4aec570181db36201696b79f3a": 1 },
          "blocks": { "0xc82fc3693d8a0d4aec570181db36201696b79f3a": 1 },
          "stakes": { "0xc82fc3693d8a0d4aec570181db36201696b79f3a": 1 },
          "tokenTotalSupply": 1
        },
        "script": "\"use strict\";\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _StackedFloat_Transfer, _StackedFloat_Approval;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst muffin_utils_1 = require(\"muffin-utils\");\nclass StackedFloat extends muffin_utils_1.App {\n    constructor(data) {\n        super(data);\n        this.tokenName = 'Stacked Float';\n        this.tokenSymbol = 'SFT';\n        // Events\n        _StackedFloat_Transfer.set(this, (from, to, value) => {\n            if (value > this.balances[from]) {\n                throw Error('Not enough funds.');\n            }\n            this.balances[from] -= value;\n            if (!this.balances[to]) {\n                this.balances[to] = 0;\n            }\n            this.balances[to] += value;\n            this.blocks[from] = 0;\n            this.stakes[from] = 0;\n        });\n        _StackedFloat_Approval.set(this, (owner, spender, value) => {\n            if (!this.allowed[this.msg.sender]) {\n                this.allowed[this.msg.sender] = {};\n            }\n            this.allowed[this.msg.sender][spender] = value;\n        }\n        // Methods\n        );\n        // Methods\n        this.name = () => {\n            return this.tokenName;\n        };\n        this.symbol = () => {\n            return this.tokenSymbol;\n        };\n        this.totalSupply = () => {\n            return this.tokenTotalSupply;\n        };\n        this.balanceOf = (owner) => {\n            if (!this.balances[owner]) {\n                return 0;\n            }\n            return this.balances[owner];\n        };\n        this.transfer = (to, value) => {\n            __classPrivateFieldGet(this, _StackedFloat_Transfer, \"f\").call(this, this.msg.sender, to, value);\n        };\n        this.transferFrom = (from, to, value) => {\n            if (!this.allowed[from] || !this.allowed[from][this.msg.sender]) {\n                throw Error('Not allowed.');\n            }\n            if (value > this.allowed[from][this.msg.sender]) {\n                throw Error('Amount unallowed.');\n            }\n            this.allowed[from][this.msg.sender] -= value;\n            __classPrivateFieldGet(this, _StackedFloat_Transfer, \"f\").call(this, from, to, value);\n        };\n        this.approve = (spender, value) => {\n            if (!this.balances[this.msg.sender] ||\n                value > this.balances[this.msg.sender]) {\n                throw Error('Not enough funds.');\n            }\n            __classPrivateFieldGet(this, _StackedFloat_Approval, \"f\").call(this, this.msg.sender, spender, value);\n        };\n        this.allowance = (owner, spender) => {\n            if (!this.allowed[owner] || !this.allowed[owner][spender]) {\n                return 0;\n            }\n            return this.allowed[owner][spender];\n        };\n        // Minting\n        this.mint = (account, amount) => {\n            if (this.msg.amount < amount * 1000) {\n                throw Error('Not enough funds. A StackedFloat costs 1000 FLT.');\n            }\n            if (this.msg.amount > amount * 1000) {\n                throw Error('Too much funds. Be careful when making transactions!');\n            }\n            if (!this.balances[account]) {\n                this.balances[account] = 0;\n            }\n            this.tokenTotalSupply += amount;\n            this.balances[account] += amount;\n        };\n        // Burning\n        this.burn = (account, amount) => {\n            if (this.balances[account] < amount) {\n                throw Error('Balance insufficient.');\n            }\n            this.tokenTotalSupply -= amount;\n            this.balances[account] -= amount;\n            this.msg.makeTransaction(account, amount * 1000);\n        };\n        if (!this.tokenTotalSupply) {\n            this.tokenTotalSupply = 0;\n        }\n        if (!this.balances) {\n            this.balances = {};\n        }\n        if (!this.allowed) {\n            this.allowed = {};\n        }\n        if (!this.blocks) {\n            this.blocks = {};\n        }\n        if (!this.stakes) {\n            this.stakes = {};\n        }\n    }\n}\n_StackedFloat_Transfer = new WeakMap(), _StackedFloat_Approval = new WeakMap();\n"
      }
    },
    {
      "address": "0x1",
      "balance": 0,
      "isOwned": false,
      "contract": {
        "environment": "nodejs",
        "className": "MuffinID",
        "storage": {
          "tokenName": "Muffin ID",
          "tokenSymbol": "MID",
          "supply": 0,
          "tokens": {
            "mxa9a9503a79d30c0b5a4f18358555c2577e1d64d682aa1e6fd2e82c8fd33f14fb": {
              "firstname": "0x7b2263697068657274657874223a2261493351746a38304d413d3d222c22656e6372797074696f6e436f6e666967223a7b22616c676f726974686d223a226165732d3235362d67636d222c226976223a22544977634e396b502f4841474d6b5153222c2261757468546167223a22657662414f2f55534f6d567348744c536161647a39513d3d227d2c226b657944657269766174696f6e436f6e666967223a7b22616c676f726974686d223a322c226c656e677468223a33322c2273616c74223a22476e566d6d504f414c332b38796e6d774336576132413d3d222c226f70734c696d6974223a322c226d656d4c696d6974223a3236383433353435367d7d",
              "middlename": "0x7b2263697068657274657874223a224e364577664e65303375645441686c5047413d3d222c22656e6372797074696f6e436f6e666967223a7b22616c676f726974686d223a226165732d3235362d67636d222c226976223a226472443346385230365269705034396c222c2261757468546167223a22626d54744659446b72373870303462584c71497863673d3d227d2c226b657944657269766174696f6e436f6e666967223a7b22616c676f726974686d223a322c226c656e677468223a33322c2273616c74223a225053434e586d61712f7547777649433854654b5371773d3d222c226f70734c696d6974223a322c226d656d4c696d6974223a3236383433353435367d7d",
              "lastname": "0x7b2263697068657274657874223a22414d74453431613935673d3d222c22656e6372797074696f6e436f6e666967223a7b22616c676f726974686d223a226165732d3235362d67636d222c226976223a22367263386e74544856644d4654716f42222c2261757468546167223a222f654d6c594379343074594f477377575250693746413d3d227d2c226b657944657269766174696f6e436f6e666967223a7b22616c676f726974686d223a322c226c656e677468223a33322c2273616c74223a225054446c476e654435624131654675777041746759673d3d222c226f70734c696d6974223a322c226d656d4c696d6974223a3236383433353435367d7d",
              "username": "0x7b2263697068657274657874223a22435953386c364f7562773d3d222c22656e6372797074696f6e436f6e666967223a7b22616c676f726974686d223a226165732d3235362d67636d222c226976223a226232506e35666b522f564868744c646a222c2261757468546167223a226b4844524b6470734d423457487230516c42717442673d3d227d2c226b657944657269766174696f6e436f6e666967223a7b22616c676f726974686d223a322c226c656e677468223a33322c2273616c74223a22722b6b355870505851564c4850334b3859326c5249673d3d222c226f70734c696d6974223a322c226d656d4c696d6974223a3236383433353435367d7d",
              "email": "0x7b2263697068657274657874223a22595a7962735244727143774156677676622f56354d694c54222c22656e6372797074696f6e436f6e666967223a7b22616c676f726974686d223a226165732d3235362d67636d222c226976223a224957654f49547a666c71343933616c61222c2261757468546167223a2241506b63393070465648304d6e306266736b773130773d3d227d2c226b657944657269766174696f6e436f6e666967223a7b22616c676f726974686d223a322c226c656e677468223a33322c2273616c74223a22304f366f5049516c6c442f44306f6565396644727a773d3d222c226f70734c696d6974223a322c226d656d4c696d6974223a3236383433353435367d7d",
              "createdAt": "2022-06-29T21:01:27.179Z",
              "birthdate": "0x7b2263697068657274657874223a22634e4a36544f434a41317579323167314d397575546d6a744a4e75634238552b67514f4179576f3430566769516b4a47704c2b366d33634b4b524c567a6833426c56416233464d4c6262374965346d71324c7979654a6333543342756450633d222c22656e6372797074696f6e436f6e666967223a7b22616c676f726974686d223a226165732d3235362d67636d222c226976223a224f4c4b4e434947494863786630787749222c2261757468546167223a22314e496d363757574b4e317a6459546b4f57486a4d513d3d227d2c226b657944657269766174696f6e436f6e666967223a7b22616c676f726974686d223a322c226c656e677468223a33322c2273616c74223a22634f4236646539464e4b79644d55314a5538692b69773d3d222c226f70734c696d6974223a322c226d656d4c696d6974223a3236383433353435367d7d"
            }
          },
          "owners": {
            "mxa9a9503a79d30c0b5a4f18358555c2577e1d64d682aa1e6fd2e82c8fd33f14fb": "0xc82fc3693d8a0d4aec570181db36201696b79f3a"
          },
          "balances": { "0xc82fc3693d8a0d4aec570181db36201696b79f3a": 1 },
          "credentials": {
            "mxa9a9503a79d30c0b5a4f18358555c2577e1d64d682aa1e6fd2e82c8fd33f14fb": "0x5aa342bc337962e8b1f880abe2670139f11bd5cfc0285533ad87e9eee0ae7d56"
          }
        },
        "script": "\"use strict\";\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MuffinID_GenerateHash, _MuffinID_Authenticate;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst muffin_utils_1 = require(\"muffin-utils\");\nclass MuffinID extends muffin_utils_1.App {\n    constructor(data) {\n        super(data);\n        this.tokenName = 'Muffin ID';\n        this.tokenSymbol = 'MID';\n        _MuffinID_GenerateHash.set(this, (token) => {\n            const hashed = (0, muffin_utils_1.hash)(`${token.firstname}${token.lastname}${token.birthdate}`);\n            const slicedHash = hashed.slice(2);\n            const muffinAddress = `mx${slicedHash}`;\n            return muffinAddress;\n        });\n        _MuffinID_Authenticate.set(this, (muffinAddress, signature, recovery) => {\n            const hashedAddress = (0, muffin_utils_1.hash)(muffinAddress);\n            const { publicKey } = (0, muffin_utils_1.verifySignature)(signature, hashedAddress, recovery);\n            const credential = (0, muffin_utils_1.hash)(`${publicKey}${muffinAddress}`);\n            if (this.credentials[muffinAddress] != credential) {\n                throw Error('Unauthorized.');\n            }\n            return true;\n        });\n        this.balanceOf = (owner) => {\n            return this.balances[owner] || 0;\n        };\n        this.ownerOf = (tokenId) => {\n            if (!this.owners[tokenId]) {\n                throw \"Specified Muffin ID doesn't exist.\";\n            }\n            return this.owners[tokenId];\n        };\n        this.name = () => {\n            return this.tokenName;\n        };\n        this.symbol = () => {\n            return this.tokenSymbol;\n        };\n        this.field = (tokenId, field) => {\n            if (!this.tokens[tokenId]) {\n                throw Error(\"This Muffin ID doesn't exist.\");\n            }\n            if (!(field in this.tokens[tokenId])) {\n                throw Error(\"This field doesn't exist.\");\n            }\n            return this.tokens[tokenId][field];\n        };\n        this.getMuffinID = (muffinAddress) => {\n            return this.tokens[muffinAddress];\n        };\n        // Minting\n        this.mint = (data, signature, recovery) => {\n            // Checking that the price has been paid\n            if (this.msg.amount != 5) {\n                throw Error('The price for purchasing a Muffin ID is 5 FLT. No more, no less.');\n            }\n            const { firstname, middlename, lastname, username, email, picture, birthdate, } = JSON.parse(data);\n            // Verifying data\n            if (!firstname || typeof firstname != 'string') {\n                throw Error('A Muffin ID must have a firstname.');\n            }\n            if (!middlename || typeof middlename != 'string') {\n                throw Error('A Muffin ID must have a middlename.');\n            }\n            if (!lastname || typeof lastname != 'string') {\n                throw Error('A Muffin ID must have a lastname.');\n            }\n            if (!username || typeof username != 'string') {\n                throw Error('A Muffin ID must have a username.');\n            }\n            if (!email || typeof email != 'string') {\n                throw Error('A Muffin ID must have an email.');\n            }\n            if (!birthdate) {\n                throw Error('A Muffin ID must have a birth date.');\n            }\n            const createdAt = new Date();\n            const token = {\n                firstname,\n                middlename,\n                lastname,\n                username,\n                email,\n                createdAt,\n                picture,\n                birthdate,\n            };\n            // Generating hash\n            const tokenHash = __classPrivateFieldGet(this, _MuffinID_GenerateHash, \"f\").call(this, token);\n            // We have to check if the Muffin ID doesn't already exist\n            if (this.tokens[tokenHash]) {\n                throw Error('A similar Muffin ID already exists!');\n            }\n            // Registering the new Muffin ID\n            this.tokens[tokenHash] = token;\n            // Generate credentials\n            const { publicKey } = (0, muffin_utils_1.verifySignature)(signature, (0, muffin_utils_1.hash)(''), recovery);\n            const credential = (0, muffin_utils_1.hash)(`${publicKey}${tokenHash}`);\n            // Registering credentials\n            this.credentials[tokenHash] = credential;\n            // Bonding Muffin ID with account address\n            this.owners[tokenHash] = this.msg.sender;\n            // Updating balane of owner\n            this.balances[this.msg.sender] = 1;\n            return;\n        };\n        // Recovering a Muffin ID with a password\n        this.recover = (muffinAddress, signature, recovery) => {\n            if (!muffinAddress) {\n                throw Error('Must specify a Muffin ID address to recover.');\n            }\n            if (!signature) {\n                throw Error('To recover a Muffin ID, the address of the muffin ID must be signed with the private key.');\n            }\n            if (this.balances[this.msg.sender] > 0) {\n                throw Error('A Muffin ID is already linked to this account.');\n            }\n            __classPrivateFieldGet(this, _MuffinID_Authenticate, \"f\").call(this, muffinAddress, signature, recovery);\n            // Updating balances\n            this.balances[this.owners[muffinAddress]] = 0;\n            this.balances[this.msg.sender] = 1;\n            // Associating the recovered Muffin ID with the new account\n            this.owners[muffinAddress] = this.msg.sender;\n        };\n        this.patch = (muffinAddress, signature, recovery, data) => {\n            const { username, email, city, country, picture } = data;\n            const token = this.tokens[muffinAddress];\n            if (!token) {\n                throw Error(\"Specified Muffin ID doesn't exist.\");\n            }\n            __classPrivateFieldGet(this, _MuffinID_Authenticate, \"f\").call(this, muffinAddress, signature, recovery);\n            if (username) {\n                token.username = username;\n            }\n            if (email) {\n                token.email = email;\n            }\n            if (city) {\n                token.city = city;\n            }\n            if (country) {\n                token.country = country;\n            }\n            if (picture) {\n                token.picture = picture;\n            }\n            // Saving token\n            this.tokens[muffinAddress] = token;\n        };\n        if (!this.supply) {\n            this.supply = 0;\n        }\n        if (!this.tokens) {\n            this.tokens = {};\n        }\n        if (!this.owners) {\n            this.owners = {};\n        }\n        if (!this.balances) {\n            this.balances = {};\n        }\n        if (!this.credentials) {\n            this.credentials = {};\n        }\n    }\n}\n_MuffinID_GenerateHash = new WeakMap(), _MuffinID_Authenticate = new WeakMap();\n"
      }
    },
    {
      "address": "0xc82fc3693d8a0d4aec570181db36201696b79f3a",
      "balance": 5000,
      "isOwned": true
    }
  ]
}
