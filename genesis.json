{
  "chainId": 1985,
  "blockHash": "0x0",
  "blockHeight": 0,
  "taxRate": 0.01,
  "idCount": 1,

  "accounts": [
    {
      "address": "0x0",
      "balance": 1000,
      "isOwned": false,
      "contract": {
        "environment": "nodejs",
        "className": "StackedFloat",
        "storage": {
          "balances": { "0xc82fc3693d8a0d4aec570181db36201696b79f3a": 1 },
          "blocks": { "0xc82fc3693d8a0d4aec570181db36201696b79f3a": 1 },
          "stakes": { "0xc82fc3693d8a0d4aec570181db36201696b79f3a": 1 },
          "tokenTotalSupply": 1
        },
        "footprint": 1,
        "script": "\"use strict\";\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _StackedFloat_Transfer, _StackedFloat_Approval;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst muffin_utils_1 = require(\"muffin-utils\");\nclass StackedFloat extends muffin_utils_1.App {\n    constructor(data) {\n        super(data);\n        this.tokenName = 'Stacked Float';\n        this.tokenSymbol = 'SFT';\n        // Events\n        _StackedFloat_Transfer.set(this, (from, to, value) => {\n            if (value > this.balances[from]) {\n                throw Error('Not enough funds.');\n            }\n            this.balances[from] -= value;\n            if (!this.balances[to]) {\n                this.balances[to] = 0;\n            }\n            this.balances[to] += value;\n            this.blocks[from] = 0;\n            this.stakes[from] = 0;\n        });\n        _StackedFloat_Approval.set(this, (owner, spender, value) => {\n            if (!this.allowed[this.msg.sender]) {\n                this.allowed[this.msg.sender] = {};\n            }\n            this.allowed[this.msg.sender][spender] = value;\n        }\n        // Methods\n        );\n        // Methods\n        this.name = () => {\n            return this.tokenName;\n        };\n        this.symbol = () => {\n            return this.tokenSymbol;\n        };\n        this.totalSupply = () => {\n            return this.tokenTotalSupply;\n        };\n        this.balanceOf = (owner) => {\n            if (!this.balances[owner]) {\n                return 0;\n            }\n            return this.balances[owner];\n        };\n        this.transfer = (to, value) => {\n            __classPrivateFieldGet(this, _StackedFloat_Transfer, \"f\").call(this, this.msg.sender, to, value);\n        };\n        this.transferFrom = (from, to, value) => {\n            if (!this.allowed[from] || !this.allowed[from][this.msg.sender]) {\n                throw Error('Not allowed.');\n            }\n            if (value > this.allowed[from][this.msg.sender]) {\n                throw Error('Amount unallowed.');\n            }\n            this.allowed[from][this.msg.sender] -= value;\n            __classPrivateFieldGet(this, _StackedFloat_Transfer, \"f\").call(this, from, to, value);\n        };\n        this.approve = (spender, value) => {\n            if (!this.balances[this.msg.sender] ||\n                value > this.balances[this.msg.sender]) {\n                throw Error('Not enough funds.');\n            }\n            __classPrivateFieldGet(this, _StackedFloat_Approval, \"f\").call(this, this.msg.sender, spender, value);\n        };\n        this.allowance = (owner, spender) => {\n            if (!this.allowed[owner] || !this.allowed[owner][spender]) {\n                return 0;\n            }\n            return this.allowed[owner][spender];\n        };\n        // Minting\n        this.mint = (account, amount) => {\n            if (this.msg.amount < amount * 1000) {\n                throw Error('Not enough funds. A StackedFloat costs 1000 FLT.');\n            }\n            if (this.msg.amount > amount * 1000) {\n                throw Error('Too much funds. Be careful when making transactions!');\n            }\n            if (!this.balances[account]) {\n                this.balances[account] = 0;\n            }\n            this.tokenTotalSupply += amount;\n            this.balances[account] += amount;\n        };\n        // Burning\n        this.burn = (account, amount) => {\n            if (this.balances[account] < amount) {\n                throw Error('Balance insufficient.');\n            }\n            this.tokenTotalSupply -= amount;\n            this.balances[account] -= amount;\n            this.msg.makeTransaction(account, amount * 1000);\n        };\n        if (!this.tokenTotalSupply) {\n            this.tokenTotalSupply = 0;\n        }\n        if (!this.balances) {\n            this.balances = {};\n        }\n        if (!this.allowed) {\n            this.allowed = {};\n        }\n        if (!this.blocks) {\n            this.blocks = {};\n        }\n        if (!this.stakes) {\n            this.stakes = {};\n        }\n    }\n}\n_StackedFloat_Transfer = new WeakMap(), _StackedFloat_Approval = new WeakMap();\n"
      }
    },
    {
      "address": "0x1",
      "balance": 0,
      "isOwned": false,
      "contract": {
        "environment": "nodejs",
        "className": "MuffinID",
        "storage": {},
        "footprint": 1,
        "script": "\"use strict\";\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _MuffinID_GenerateHash, _MuffinID_Authenticate, _MuffinID_Authorized;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst muffin_utils_1 = require(\"muffin-utils\");\nclass MuffinID extends muffin_utils_1.App {\n    constructor(data) {\n        super(data);\n        this.tokenName = 'Muffin ID';\n        this.tokenSymbol = 'MID';\n        this.accessList = {\n            '0xc82fc3693d8a0d4aec570181db36201696b79f3a': true,\n            '0x9a9af2c45656d36116c51772daad9a4ce4af119d': true,\n            '0x66dd45959911e855e6b0ef3c7c2cd17b389bd914': true,\n        };\n        _MuffinID_GenerateHash.set(this, (token) => {\n            const hashed = (0, muffin_utils_1.hash)(`${token.firstname}${token.lastname}${token.birthdate}`);\n            const slicedHash = hashed.slice(2);\n            const muffinAddress = `mx${slicedHash}`;\n            return muffinAddress;\n        });\n        _MuffinID_Authenticate.set(this, (muffinAddress, signature, recovery) => {\n            const hashedAddress = (0, muffin_utils_1.hash)(muffinAddress);\n            const { publicKey } = (0, muffin_utils_1.verifySignature)(signature, hashedAddress, recovery);\n            const credential = (0, muffin_utils_1.hash)(`${publicKey}${muffinAddress}`);\n            if (this.credentials[muffinAddress] != credential) {\n                throw Error('Unauthorized.');\n            }\n            return true;\n        });\n        _MuffinID_Authorized.set(this, (address) => {\n            if (!this.whitelist[address]) {\n                throw Error('Transaction sender is not whitelisted.');\n            }\n            return true;\n        });\n        this.whitelistAddress = (address) => {\n            if (!this.accessList[this.msg.sender]) {\n                throw Error('Sender is not authorized to do this action.');\n            }\n            this.whitelist[address] = true;\n            return;\n        };\n        this.disableWhitelist = () => {\n            if (!this.accessList[this.msg.sender]) {\n                throw Error('Sender is not authorized to do this action.');\n            }\n            this.useWhitelist = false;\n            return;\n        };\n        this.balanceOf = (owner) => {\n            return this.balances[owner] || 0;\n        };\n        this.ownerOf = (tokenId) => {\n            if (!this.owners[tokenId]) {\n                throw \"Specified Muffin ID doesn't exist.\";\n            }\n            return this.owners[tokenId];\n        };\n        this.name = () => {\n            return this.tokenName;\n        };\n        this.symbol = () => {\n            return this.tokenSymbol;\n        };\n        this.field = (tokenId, field) => {\n            if (!this.tokens[tokenId]) {\n                throw Error(\"This Muffin ID doesn't exist.\");\n            }\n            if (!(field in this.tokens[tokenId])) {\n                throw Error(\"This field doesn't exist.\");\n            }\n            return this.tokens[tokenId][field];\n        };\n        this.getMuffinID = (muffinAddress) => {\n            return this.tokens[muffinAddress];\n        };\n        // Minting\n        this.mint = (data, signature, recovery) => {\n            // Checking that the address is whitelisted\n            __classPrivateFieldGet(this, _MuffinID_Authorized, \"f\").call(this, this.msg.sender);\n            // Checking that the price has been paid\n            if (this.msg.amount != 60) {\n                throw Error('The price for purchasing a Muffin ID is 60 FLT.');\n            }\n            const { firstname, middlename, lastname, username, email, picture, birthdate, } = JSON.parse(data);\n            // Verifying data\n            if (!firstname || typeof firstname != 'string') {\n                throw Error('A Muffin ID must have a firstname.');\n            }\n            if (!middlename || typeof middlename != 'string') {\n                throw Error('A Muffin ID must have a middlename.');\n            }\n            if (!lastname || typeof lastname != 'string') {\n                throw Error('A Muffin ID must have a lastname.');\n            }\n            if (!username || typeof username != 'string') {\n                throw Error('A Muffin ID must have a username.');\n            }\n            if (!email || typeof email != 'string') {\n                throw Error('A Muffin ID must have an email.');\n            }\n            if (!birthdate) {\n                throw Error('A Muffin ID must have a birth date.');\n            }\n            const createdAt = new Date();\n            const token = {\n                firstname,\n                middlename,\n                lastname,\n                username,\n                email,\n                createdAt,\n                picture,\n                birthdate,\n            };\n            // Generating hash\n            const tokenHash = __classPrivateFieldGet(this, _MuffinID_GenerateHash, \"f\").call(this, token);\n            // We have to check if the Muffin ID doesn't already exist\n            if (this.tokens[tokenHash]) {\n                throw Error('A similar Muffin ID already exists!');\n            }\n            // Registering the new Muffin ID\n            this.tokens[tokenHash] = token;\n            // Generate credentials\n            const { publicKey } = (0, muffin_utils_1.verifySignature)(signature, (0, muffin_utils_1.hash)(''), recovery);\n            const credential = (0, muffin_utils_1.hash)(`${publicKey}${tokenHash}`);\n            // Registering credentials\n            this.credentials[tokenHash] = credential;\n            // Bonding Muffin ID with account address\n            this.owners[tokenHash] = this.msg.sender;\n            // Updating balane of owner\n            this.balances[this.msg.sender] = 1;\n            this.supply++;\n            return;\n        };\n        // Recovering a Muffin ID with a password\n        this.recover = (muffinAddress, signature, recovery) => {\n            if (!muffinAddress) {\n                throw Error('Must specify a Muffin ID address to recover.');\n            }\n            if (!signature) {\n                throw Error('To recover a Muffin ID, the address of the muffin ID must be signed with the private key.');\n            }\n            if (this.balances[this.msg.sender] > 0) {\n                throw Error('A Muffin ID is already linked to this account.');\n            }\n            __classPrivateFieldGet(this, _MuffinID_Authenticate, \"f\").call(this, muffinAddress, signature, recovery);\n            // Updating balances\n            this.balances[this.owners[muffinAddress]] = 0;\n            this.balances[this.msg.sender] = 1;\n            // Associating the recovered Muffin ID with the new account\n            this.owners[muffinAddress] = this.msg.sender;\n        };\n        this.patch = (muffinAddress, signature, recovery, data) => {\n            const { username, email, city, country, picture } = data;\n            const token = this.tokens[muffinAddress];\n            if (!token) {\n                throw Error(\"Specified Muffin ID doesn't exist.\");\n            }\n            __classPrivateFieldGet(this, _MuffinID_Authenticate, \"f\").call(this, muffinAddress, signature, recovery);\n            if (username) {\n                token.username = username;\n            }\n            if (email) {\n                token.email = email;\n            }\n            if (city) {\n                token.city = city;\n            }\n            if (country) {\n                token.country = country;\n            }\n            if (picture) {\n                token.picture = picture;\n            }\n            // Saving token\n            this.tokens[muffinAddress] = token;\n        };\n        if (!this.supply) {\n            this.supply = 0;\n        }\n        if (!this.tokens) {\n            this.tokens = {};\n        }\n        if (!this.owners) {\n            this.owners = {};\n        }\n        if (!this.balances) {\n            this.balances = {};\n        }\n        if (!this.credentials) {\n            this.credentials = {};\n        }\n        if (!this.whitelist) {\n            this.whitelist = {\n                '0xc82fc3693d8a0d4aec570181db36201696b79f3a': true,\n                '0x9a9af2c45656d36116c51772daad9a4ce4af119d': true,\n                '0x66dd45959911e855e6b0ef3c7c2cd17b389bd914': true,\n            };\n        }\n        if (this.useWhitelist != false) {\n            this.useWhitelist = true;\n        }\n    }\n}\n_MuffinID_GenerateHash = new WeakMap(), _MuffinID_Authenticate = new WeakMap(), _MuffinID_Authorized = new WeakMap();\n"
      }
    },
    {
      "address": "0xc82fc3693d8a0d4aec570181db36201696b79f3a",
      "balance": 5000,
      "isOwned": true
    }
  ]
}
